# 第五次实验报告

## firewall 实验

### source_routing.p4
```c++
/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

/* CONSTANTS */

const bit<16> TYPE_IPV4 = 0x800;
const bit<8>  TYPE_TCP  = 6;

#define BLOOM_FILTER_ENTRIES 4096
#define BLOOM_FILTER_BIT_WIDTH 1
#define BLOOM_FILTER_OCCUPATION 1

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

typedef bit<9>  egressSpec_t;
typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;

header ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

header tcp_t{
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<4>  res;
    bit<1>  cwr;
    bit<1>  ece;
    bit<1>  urg;
    bit<1>  ack;
    bit<1>  psh;
    bit<1>  rst;
    bit<1>  syn;
    bit<1>  fin;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

struct metadata {
    /* empty */
}

struct headers {
    ethernet_t   ethernet;
    ipv4_t       ipv4;
    tcp_t        tcp;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol){
            TYPE_TCP: tcp;
            default: accept;
        }
    }

    state tcp {
       packet.extract(hdr.tcp);
       transition accept;
    }
}

/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {   
    apply {  }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {

    //开辟寄存器数组，数组下标为[0,BLOOM_FILTER_ENTRIES-1]
    //每个下标对应一个bit<BLOOM_FILTER_BIT_WIDTH>类型的数据
    register<bit<BLOOM_FILTER_BIT_WIDTH>>(BLOOM_FILTER_ENTRIES) bloom_filter_1;
    register<bit<BLOOM_FILTER_BIT_WIDTH>>(BLOOM_FILTER_ENTRIES) bloom_filter_2;
    bit<32> reg_pos_one; bit<32> reg_pos_two;
    bit<1> reg_val_one; bit<1> reg_val_two;
    //direction表示包的发送方向，进入内网的为1，内网发出的为0
    //只有由内向外的包和由外向内的包，direction有效，其余情况不计算direction
    bit<1> direction;

    action drop() {
        mark_to_drop(standard_metadata);
    }

    action compute_hashes(ip4Addr_t ipAddr1, ip4Addr_t ipAddr2, bit<16> port1, bit<16> port2){
       //Get register position
       //利用两个不同的哈希函数crc16和crc32分别得到两个寄存器位置
       //返回值在[0,4095]之间
       hash(reg_pos_one, HashAlgorithm.crc16, (bit<32>)0, {ipAddr1,
                                                           ipAddr2,
                                                           port1,
                                                           port2,
                                                           hdr.ipv4.protocol},
                                                           (bit<32>)BLOOM_FILTER_ENTRIES);

       hash(reg_pos_two, HashAlgorithm.crc32, (bit<32>)0, {ipAddr1,
                                                           ipAddr2,
                                                           port1,
                                                           port2,
                                                           hdr.ipv4.protocol},
                                                           (bit<32>)BLOOM_FILTER_ENTRIES);
    }

    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) {
        standard_metadata.egress_spec = port;
        hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;
        hdr.ethernet.dstAddr = dstAddr;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }
    
    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            ipv4_forward;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = drop();
    }

    action set_direction(bit<1> dir) {
        direction = dir;
    }

    table check_ports {
        key = {
            //同时精确匹配出入端口来判断包的发送方向
            standard_metadata.ingress_port: exact;
            standard_metadata.egress_spec: exact;
        }
        actions = {
            set_direction;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }
    
    apply {
        if (hdr.ipv4.isValid()){
            ipv4_lpm.apply();
            if (hdr.tcp.isValid()){
                direction = 0; // default
                //计算direction，并通过端口是否匹配成功来判断direction是否有效
                //根据流表规则的下发设定，可以使内网之间包以及外网之间的包不需要经过布隆过滤器
                if (check_ports.apply().hit) {
                    // test and set the bloom filter
                    if (direction == 0) {
                        //内网发出的包，源在前，目的在后
                        compute_hashes(hdr.ipv4.srcAddr, hdr.ipv4.dstAddr, hdr.tcp.srcPort, hdr.tcp.dstPort);
                    }
                    else {
                        //内网接收的包，为与上在计算结果上一致，目的在前，源在后
                        compute_hashes(hdr.ipv4.dstAddr, hdr.ipv4.srcAddr, hdr.tcp.dstPort, hdr.tcp.srcPort);
                    }
                    // Packet comes from internal network
                    if (direction == 0){
                        // TODO: this packet is part of an outgoing TCP connection.
                        //   We need to set the bloom filter if this is a SYN packet
                        //   E.g. bloom_filter_1.write(<index>, <value>);
                        //向寄存器中的两个哈希位置分别写入1
                        bloom_filter_1.write(reg_pos_one,BLOOM_FILTER_OCCUPATION);
                        bloom_filter_2.write(reg_pos_two,BLOOM_FILTER_OCCUPATION);
                    }
                    // Packet comes from outside
                    else if (direction == 1){
                        // TODO: this packet is part of an incomming TCP connection.
                        //   We need to check if this packet is allowed to pass by reading the bloom filter
                        //   E.g. bloom_filter_1.read(<value>, <index>);
                        bloom_filter_1.read(reg_val_one,reg_pos_one);
                        bloom_filter_2.read(reg_val_two,reg_pos_two);
                        //判断是否是内网先发出的包
                        if (reg_val_one != BLOOM_FILTER_OCCUPATION || reg_val_two !=BLOOM_FILTER_OCCUPATION)
                        {
                            //内网并未向该地址发过包，故直接丢弃该包
                            drop();
                        }
                    }
                }
            }
        }
    }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {  }
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
     apply {
	update_checksum(
	    hdr.ipv4.isValid(),
            { hdr.ipv4.version,
	      hdr.ipv4.ihl,
              hdr.ipv4.diffserv,
              hdr.ipv4.totalLen,
              hdr.ipv4.identification,
              hdr.ipv4.flags,
              hdr.ipv4.fragOffset,
              hdr.ipv4.ttl,
              hdr.ipv4.protocol,
              hdr.ipv4.srcAddr,
              hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum,
            HashAlgorithm.csum16);
    }
}

/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;

```

### 实验结果

完善代码前，`h1→h2` `h1→h3` `h3→h1`均可正常收发报文，带宽正常
![incomplete](.\image\firewall\incomplete.png)

完善代码后，`h1→h2` `h1→h3`仍然正常，`h3→h1`已无法测出带宽
![test](.\image\firewall\test.png)

### 思考题
+ 现有的代码在 Register 操作方面有什么缺陷？
现有代码没有编写 Register 的清空操作，当内外向外网发起的连接结束时，应当清除对应的寄存器位。否则当长时间运行时，随着寄存器中位置不断被占，布隆过滤器的误判率将会快速上升。


## link monitor 实验

### link_monitor.p4

```c++
/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

const bit<16> TYPE_IPV4  = 0x800;
const bit<16> TYPE_PROBE = 0x812;

#define MAX_HOPS 10
#define MAX_PORTS 8

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

typedef bit<9>  egressSpec_t;
typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;

typedef bit<48> time_t;

header ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

// Top-level probe header, indicates how many hops this probe
// packet has traversed so far.
//记录已经经过的交换机跳数
header probe_t {
    bit<8> hop_cnt;
}

// The data added to the probe by each switch at each hop.
header probe_data_t {
    bit<1>    bos;    //bottom of stack 1表示最后栈底，即第一跳
    bit<7>    swid;    //交换机编号
    bit<8>    port;    //交换机出端口号
    bit<32>   byte_cnt;    //距上次探针到达已发送的字节数
    time_t    last_time;    //上次到达的时间
    time_t    cur_time;    //这次到达的时间
}

// Indicates the egress port the switch should send this probe
// packet out of. There is one of these headers for each hop.
//记录交换机发送探测包的出口端口，每跳都有一个这样的报头
//由发送探针的主机直接确定每一条的出端口，相当于源路由
header probe_fwd_t {
    bit<8>   egress_spec;
}

struct parser_metadata_t {
    bit<8>  remaining;
}

struct metadata {
    //记录这一条的出端口
    bit<8> egress_spec;
    //剩余探测报头数，解析probe_data时加一，解析probe_fwd时减一，以便找到这台交换机对应的出端口
    parser_metadata_t parser_metadata;
}

struct headers {
    ethernet_t              ethernet;
    ipv4_t                  ipv4;
    probe_t                 probe;
    probe_data_t[MAX_HOPS]  probe_data;
    probe_fwd_t[MAX_HOPS]   probe_fwd;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4: parse_ipv4;
            TYPE_PROBE: parse_probe;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition accept;
    }

    state parse_probe {
        packet.extract(hdr.probe);
        meta.parser_metadata.remaining = hdr.probe.hop_cnt + 1;
        //hdr.probe.hop_cnt为0说明还没有经过任何一个交换机，故应直接解析源路由
        transition select(hdr.probe.hop_cnt) {
            0: parse_probe_fwd;
            default: parse_probe_data;
        }
    }

    state parse_probe_data {
        packet.extract(hdr.probe_data.next);
        transition select(hdr.probe_data.last.bos) {
            1: parse_probe_fwd;
            default: parse_probe_data;
        }
    }

    state parse_probe_fwd {
        packet.extract(hdr.probe_fwd.next);
        meta.parser_metadata.remaining = meta.parser_metadata.remaining - 1;
        // extract the forwarding data
        meta.egress_spec = hdr.probe_fwd.last.egress_spec;
        transition select(meta.parser_metadata.remaining) {
            0: accept;
            default: parse_probe_fwd;
        }
    }
}

/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {   
    apply {  }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {

    action drop() {
        mark_to_drop(standard_metadata);
    }
    
    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) {
        standard_metadata.egress_spec = port;
        hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;
        hdr.ethernet.dstAddr = dstAddr;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }
    
    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            ipv4_forward;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = drop();
    }
    
    apply {
        if (hdr.ipv4.isValid()) {
            ipv4_lpm.apply();
        }
        else if (hdr.probe.isValid()) {
            standard_metadata.egress_spec = (bit<9>)meta.egress_spec;
            hdr.probe.hop_cnt = hdr.probe.hop_cnt + 1;
        }
    }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   ********************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {

    // count the number of bytes seen since the last probe
    register<bit<32>>(MAX_PORTS) byte_cnt_reg;
    // remember the time of the last probe
    register<time_t>(MAX_PORTS) last_time_reg;

    action set_swid(bit<7> swid) {
        hdr.probe_data[0].swid = swid;
    }

    table swid {
        actions = {
            set_swid;
            NoAction;
        }
        default_action = NoAction();
    }

    apply {
        bit<32> byte_cnt;
        bit<32> new_byte_cnt;
        time_t last_time;
        time_t cur_time = standard_metadata.egress_global_timestamp;
        // increment byte cnt for this packet's port
        byte_cnt_reg.read(byte_cnt, (bit<32>)standard_metadata.egress_port);
        //计算加上这个包后的新byte_cnt
        byte_cnt = byte_cnt + standard_metadata.packet_length;
        // reset the byte count when a probe packet passes through
        //探针到达时清空byte_cnt_reg以重新计数，否则继续计数
        new_byte_cnt = (hdr.probe.isValid()) ? 0 : byte_cnt;
        byte_cnt_reg.write((bit<32>)standard_metadata.egress_port, new_byte_cnt);

        if (hdr.probe.isValid()) {
            // fill out probe fields
            //插入新报头记录这台交换机的数据
            hdr.probe_data.push_front(1);
            hdr.probe_data[0].setValid();
            //如果这是第一跳，标上栈底标记
            if (hdr.probe.hop_cnt == 1) {
                hdr.probe_data[0].bos = 1;
            }
            else {
                hdr.probe_data[0].bos = 0;
            }
            // set switch ID field
            //写上交换机编号
            swid.apply();
            // TODO: fill out the rest of the probe packet fields
            // hdr.probe_data[0].port = ...
            // hdr.probe_data[0].byte_cnt = ...
            //写入报头的端口和发送字节数
            hdr.probe_data[0].port = (bit<8>)standard_metadata.egress_port;
            hdr.probe_data[0].byte_cnt = byte_cnt;
            // TODO: read / update the last_time_reg
            // last_time_reg.read(<val>, <index>);
            // last_time_reg.write(<index>, <val>); 
            // hdr.probe_data[0].last_time = ...
            // hdr.probe_data[0].cur_time = ...
            //读取并更新寄存器存储的时间
            last_time_reg.read(last_time,(bit<32>)standard_metadata.egress_port);
            last_time_reg.write((bit<32>)standard_metadata.egress_port,cur_time);
            //写入报头的时间数据
            hdr.probe_data[0].last_time = last_time;
            hdr.probe_data[0].cur_time = cur_time;
        }
    }
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   ***************
*************************************************************************/

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
     apply {
	update_checksum(
	    hdr.ipv4.isValid(),
            { hdr.ipv4.version,
	      hdr.ipv4.ihl,
              hdr.ipv4.diffserv,
              hdr.ipv4.totalLen,
              hdr.ipv4.identification,
              hdr.ipv4.flags,
              hdr.ipv4.fragOffset,
              hdr.ipv4.ttl,
              hdr.ipv4.protocol,
              hdr.ipv4.srcAddr,
              hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum,
            HashAlgorithm.csum16);
    }
}

/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.probe);
        packet.emit(hdr.probe_data);
        packet.emit(hdr.probe_fwd);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
```

### 实验结果

完善代码前，无法检测到各个端口的情况
![incomplete](.\image\link_monitor\incomplete.png)

完善代码后，可以看到指定路径上每个交换的出口端口吞吐率
![complete](.\image\link_monitor\complete.png)


## 提高题 firewall

### mycontroller.py
```python
#!/usr/bin/env python3
import argparse
import grpc
import os
import sys
from time import sleep

# Import P4Runtime lib from parent utils dir
# Probably there's a better way of doing this.
sys.path.append(
    os.path.join(os.path.dirname(os.path.abspath(__file__)),
                 '../utils/'))
import p4runtime_lib.bmv2
from p4runtime_lib.error_utils import printGrpcError
from p4runtime_lib.switch import ShutdownAllSwitchConnections
import p4runtime_lib.helper

#mac address
#s1
S1_1_MAC = "00:00:00:00:01:01"
S1_2_MAC = "00:00:00:00:01:02"
S1_3_MAC = "00:00:00:00:01:03"
S1_4_MAC = "00:00:00:00:01:04"
#s2
S2_1_MAC = "00:00:00:00:02:01"
S2_2_MAC = "00:00:00:00:02:02"
S2_3_MAC = "00:00:00:00:02:03"
S2_4_MAC = "00:00:00:00:02:04"
#s3
S3_1_MAC = "00:00:00:00:03:01"
S3_2_MAC = "00:00:00:00:03:02"
S3_3_MAC = "00:00:00:00:03:03"
S3_4_MAC = "00:00:00:00:03:04"
#s4
S4_1_MAC = "00:00:00:00:04:01"
S4_2_MAC = "00:00:00:00:04:02"
S4_3_MAC = "00:00:00:00:04:03"
S4_4_MAC = "00:00:00:00:04:04"
#H
H1_MAC = "08:00:00:00:01:11"
H2_MAC = "08:00:00:00:02:22"
H3_MAC = "08:00:00:00:03:33"
H4_MAC = "08:00:00:00:04:44"

def writeIpv4Rules(p4info_helper, sw, dst_eth_addr, dst_ip_addr, ip_mask, port_id):
    """
    write rules to table ipv4_lpm
    :param p4info_helper: the P4Info helper
    :param sw: the witch connection
    :param dst_eth_addr: the destination IP to match in the ingress rule
    :param dst_ip_addr: the destination Ethernet address to write in the
                        egress rule
    :param port_id: the egress port
    """
    table_entry = p4info_helper.buildTableEntry(
        table_name = "MyIngress.ipv4_lpm",
        match_fields = {
            "hdr.ipv4.dstAddr": (dst_ip_addr, ip_mask)
        },
        action_name = "MyIngress.ipv4_forward",
        action_params = {
            "dstAddr": dst_eth_addr,
            "port": port_id
        })
    sw.WriteTableEntry(table_entry)
    print("Installed rule on %s" % sw.name)

def writeIpv4DefaultDropAction(p4info_helper, sw):
    """
    write rules to table ipv4_lpm
    :param p4info_helper: the P4Info helper
    :param sw: the witch connection
    """
    table_entry = p4info_helper.buildTableEntry(
        table_name = "MyIngress.ipv4_lpm",
        default_action = True,
        action_name = "MyIngress.drop",
        action_params = {})
    sw.WriteTableEntry(table_entry)
    print("Installed rule on %s" % sw.name)

def writeCheckPortRules(p4info_helper, sw, ingress_port, egress_port, dir):
    """
    write rules to table ipv4_lpm
    :param p4info_helper: the P4Info helper
    :param sw: the witch connection
    :param ingress_port: the ingress port index
    :param egress_port: the egress port index
    :param dir: the direction of package, 1 means in, 0 means out
    """
    table_entry = p4info_helper.buildTableEntry(
        table_name = "MyIngress.check_ports",
        match_fields = {
            "standard_metadata.ingress_port": ingress_port,
            "standard_metadata.egress_spec":  egress_port
        },
        action_name = "MyIngress.set_direction",
        action_params = {
            "dir": dir
        })
    sw.WriteTableEntry(table_entry)
    print("Installed rule on %s" % sw.name)


def readTableRules(p4info_helper, sw):
    """
    Reads the table entries from all tables on the switch.

    :param p4info_helper: the P4Info helper
    :param sw: the switch connection
    """
    print('\n----- Reading tables rules for %s -----' % sw.name)
    for response in sw.ReadTableEntries():
        for entity in response.entities:
            entry = entity.table_entry
            # TODO For extra credit, you can use the p4info_helper to translate
            #      the IDs in the entry to names
            #获取入口流表名并打印
            table_name = p4info_helper.get_tables_name(entry.table_id)
            print('table name: %s' % table_name)
            #获取匹配字段并打印
            print('match field:')
            for m in entry.match:
                print('    ', end='');
                print(p4info_helper.get_match_field_name(table_name, m.field_id), end=' ')
                print('%r' % (p4info_helper.get_match_field_value(m),))
            #打印流表中的行为名
            action = entry.action.action
            action_name = p4info_helper.get_actions_name(action.action_id)
            print('action name: %s' % action_name)
            #打印行为的传入参数
            print('action params:')
            for p in action.params:
                print('    ', end='');
                print(p4info_helper.get_action_param_name(action_name, p.param_id), end='')
                print(': %r' % p.value)
            print()


def printCounter(p4info_helper, sw, counter_name, index):
    """
    Reads the specified counter at the specified index from the switch. In our
    program, the index is the tunnel ID. If the index is 0, it will return all
    values from the counter.

    :param p4info_helper: the P4Info helper
    :param sw:  the switch connection
    :param counter_name: the name of the counter from the P4 program
    :param index: the counter index (in our case, the tunnel ID)
    """
    for response in sw.ReadCounters(p4info_helper.get_counters_id(counter_name), index):
        for entity in response.entities:
            counter = entity.counter_entry
            print("%s %s %d: %d packets (%d bytes)" % (
                sw.name, counter_name, index,
                counter.data.packet_count, counter.data.byte_count
            ))

def main(p4info_file_path, bmv2_file_path):
    # Instantiate a P4Runtime helper from the p4info file
    p4info_helper = p4runtime_lib.helper.P4InfoHelper(p4info_file_path)

    try:
        # Create a switch connection object for s1 and s2;
        # this is backed by a P4Runtime gRPC connection.
        # Also, dump(导出) all P4Runtime messages sent to switch to given txt files.
        s1 = p4runtime_lib.bmv2.Bmv2SwitchConnection(
            name='s1',
            address='127.0.0.1:50051',
            device_id=0,
            proto_dump_file='logs/s1-p4runtime-requests.txt')
        s2 = p4runtime_lib.bmv2.Bmv2SwitchConnection(
            name='s2',
            address='127.0.0.1:50052',
            device_id=1,
            proto_dump_file='logs/s2-p4runtime-requests.txt')
        s3 = p4runtime_lib.bmv2.Bmv2SwitchConnection(
            name='s3',
            address='127.0.0.1:50053',
            device_id=2,
            proto_dump_file='logs/s3-p4runtime-requests.txt')
        s4 = p4runtime_lib.bmv2.Bmv2SwitchConnection(
            name='s4',
            address='127.0.0.1:50054',
            device_id=3,
            proto_dump_file='logs/s4-p4runtime-requests.txt')

        # Send master arbitration update message to establish this controller as
        # master (required by P4Runtime before performing any other write operation)
        s1.MasterArbitrationUpdate()
        s2.MasterArbitrationUpdate()
        s3.MasterArbitrationUpdate()
        s4.MasterArbitrationUpdate()

        # Install the P4 program on the switches
        s1.SetForwardingPipelineConfig(p4info=p4info_helper.p4info,
                                       bmv2_json_file_path=bmv2_file_path)
        print("Installed P4 Program using SetForwardingPipelineConfig on s1")
        s2.SetForwardingPipelineConfig(p4info=p4info_helper.p4info,
                                       bmv2_json_file_path=bmv2_file_path)
        print("Installed P4 Program using SetForwardingPipelineConfig on s2")
        s3.SetForwardingPipelineConfig(p4info=p4info_helper.p4info,
                                       bmv2_json_file_path=bmv2_file_path)
        print("Installed P4 Program using SetForwardingPipelineConfig on s3")
        s4.SetForwardingPipelineConfig(p4info=p4info_helper.p4info,
                                       bmv2_json_file_path=bmv2_file_path)
        print("Installed P4 Program using SetForwardingPipelineConfig on s4")

        #install the rules of table ipv4_lpm and check_ports
        #s1
        print("install ipv4_lpm rules on s1...")
        writeIpv4Rules(p4info_helper, sw=s1, dst_eth_addr=H1_MAC,
                         dst_ip_addr="10.0.1.1", ip_mask=32, port_id=1)
        writeIpv4Rules(p4info_helper, sw=s1, dst_eth_addr=H2_MAC,
                         dst_ip_addr="10.0.2.2", ip_mask=32, port_id=2)
        writeIpv4Rules(p4info_helper, sw=s1, dst_eth_addr=S1_3_MAC,
                         dst_ip_addr="10.0.3.3", ip_mask=32, port_id=3)
        writeIpv4Rules(p4info_helper, sw=s1, dst_eth_addr=S1_4_MAC,
                         dst_ip_addr="10.0.4.4", ip_mask=32, port_id=4)
        writeIpv4DefaultDropAction(p4info_helper, sw=s1)
        print("install check_ports rules on s1...")
        writeCheckPortRules(p4info_helper, sw=s1, ingress_port=1, egress_port=3, dir=0)
        writeCheckPortRules(p4info_helper, sw=s1, ingress_port=1, egress_port=4, dir=0)
        writeCheckPortRules(p4info_helper, sw=s1, ingress_port=2, egress_port=3, dir=0)
        writeCheckPortRules(p4info_helper, sw=s1, ingress_port=2, egress_port=4, dir=0)
        writeCheckPortRules(p4info_helper, sw=s1, ingress_port=3, egress_port=1, dir=1)
        writeCheckPortRules(p4info_helper, sw=s1, ingress_port=4, egress_port=1, dir=1)
        writeCheckPortRules(p4info_helper, sw=s1, ingress_port=3, egress_port=2, dir=1)
        writeCheckPortRules(p4info_helper, sw=s1, ingress_port=4, egress_port=2, dir=1)
        #s2
        print("install ipv4_lpm rules on s2...")
        writeIpv4Rules(p4info_helper, sw=s2, dst_eth_addr=S3_2_MAC,
                         dst_ip_addr="10.0.1.1", ip_mask=32, port_id=4)
        writeIpv4Rules(p4info_helper, sw=s2, dst_eth_addr=S4_1_MAC,
                         dst_ip_addr="10.0.2.2", ip_mask=32, port_id=3)
        writeIpv4Rules(p4info_helper, sw=s2, dst_eth_addr=H3_MAC,
                         dst_ip_addr="10.0.3.3", ip_mask=32, port_id=1)
        writeIpv4Rules(p4info_helper, sw=s2, dst_eth_addr=H4_MAC,
                         dst_ip_addr="10.0.4.4", ip_mask=32, port_id=2)
        writeIpv4DefaultDropAction(p4info_helper, sw=s2)
        #s3
        print("install ipv4_lpm rules on s3...")
        writeIpv4Rules(p4info_helper, sw=s3, dst_eth_addr=S1_3_MAC,
                         dst_ip_addr="10.0.1.1", ip_mask=32, port_id=1)
        writeIpv4Rules(p4info_helper, sw=s3, dst_eth_addr=S1_3_MAC,
                         dst_ip_addr="10.0.2.2", ip_mask=32, port_id=1)
        writeIpv4Rules(p4info_helper, sw=s3, dst_eth_addr=S2_4_MAC,
                         dst_ip_addr="10.0.3.3", ip_mask=32, port_id=2)
        writeIpv4Rules(p4info_helper, sw=s3, dst_eth_addr=S2_4_MAC,
                         dst_ip_addr="10.0.4.4", ip_mask=32, port_id=2)
        writeIpv4DefaultDropAction(p4info_helper, sw=s3)
        #S4
        print("install ipv4_lpm rules on s4...")
        writeIpv4Rules(p4info_helper, sw=s4, dst_eth_addr=S1_4_MAC,
                         dst_ip_addr="10.0.1.1", ip_mask=32, port_id=2)
        writeIpv4Rules(p4info_helper, sw=s4, dst_eth_addr=S1_4_MAC,
                         dst_ip_addr="10.0.2.2", ip_mask=32, port_id=2)
        writeIpv4Rules(p4info_helper, sw=s4, dst_eth_addr=S2_3_MAC,
                         dst_ip_addr="10.0.3.3", ip_mask=32, port_id=1)
        writeIpv4Rules(p4info_helper, sw=s4, dst_eth_addr=S2_3_MAC,
                         dst_ip_addr="10.0.4.4", ip_mask=32, port_id=1)
        writeIpv4DefaultDropAction(p4info_helper, sw=s4)

        readTableRules(p4info_helper, s1)
        readTableRules(p4info_helper, s2)
        readTableRules(p4info_helper, s3)
        readTableRules(p4info_helper, s4)

    except grpc.RpcError as e:
        printGrpcError(e)

    ShutdownAllSwitchConnections()

if __name__ == '__main__':
    #创建解析对象
    parser = argparse.ArgumentParser(description='P4Runtime Controller')
    #向解析对象中添加关注的命令行参数或选项
    parser.add_argument('--p4info', help='p4info proto in text format from p4c',
                        type=str, action="store", required=False,
                        default='./build/firewall.p4.p4info.txt')
    parser.add_argument('--bmv2-json', help='BMv2 JSON file from p4c',
                        type=str, action="store", required=False,
                        default='./build/firewall.json')
    #解析命令行参数
    args = parser.parse_args()

    if not os.path.exists(args.p4info):
        parser.print_help()
        print("\np4info file not found: %s\nHave you run 'make'?" % args.p4info)
        parser.exit(1)
    if not os.path.exists(args.bmv2_json):
        parser.print_help()
        print("\nBMv2 JSON file not found: %s\nHave you run 'make'?" % args.bmv2_json)
        parser.exit(1)
    main(args.p4info, args.bmv2_json)

```

### 实验结果

运行`mycontroller.py`下发流表规则
![use mycontroller](.\image\firewall\write rules.png)

使用`pingall`验证连通性并重新检测带宽
![pingall and test](.\image\firewall\test again.png)
可见`h3→h1`的带宽无法测出

## 提高题 acl

### acl.p4

```c++
/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

const bit<16> TYPE_IPV4 = 0x800;

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

typedef bit<9>  egressSpec_t;
typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;

header ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header udp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<16> pkt_length;
    bit<16> checksum;
}

struct metadata {
    /* empty */
}

struct headers {
    ethernet_t   ethernet;
    ipv4_t       ipv4;
    tcp_t        tcp;
    udp_t        udp;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            6: parse_tcp;
            17: parse_udp;
            default: accept;
        }
    }

    state parse_tcp {
        packet.extract(hdr.tcp);
        transition accept;
    }

    state parse_udp {
        packet.extract(hdr.udp);
        transition accept;
    }

}

/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {  }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    action drop() {
        mark_to_drop(standard_metadata);
    }

    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) {
        standard_metadata.egress_spec = port;
        hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;
        hdr.ethernet.dstAddr = dstAddr;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }

    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            ipv4_forward;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = drop();
    }

    /* TODO: Create a table for access control list.
       Hints: Use ipv4_lpm table as an example.
       Hints: The table should have the following specification
          key: hdr.ipv4.dstAddr (ternary), hdr.udp.dstPort (ternary)
          actions: drop, NoAction
          size: 1024
          default action: NoAction
       Hints: Do not forget to add two rules to s1-acl.json. One rule should
          drop packets with UDP port 80, by specifying {"hdr.udp.dstPort":
          [80, 65535]} as "match". The other rule should drop packets with
          IPv4 address 10.0.1.4, by specifing {"hdr.ipv4.dstAddr": ["10.0.1.4",
          4294967295]} as "match".
       Notes: The priority field must be set to a non-zero value 
              if the match key includes a ternary match.
     */
    table acl_ternary {
        key = {
            hdr.ipv4.dstAddr: ternary;
            hdr.udp.dstPort: ternary;
        }
        actions = {
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    apply {
        if (hdr.ipv4.isValid()) {
            ipv4_lpm.apply();
            /* TODO: add your table to the control flow */
            if (hdr.udp.isValid())
            acl_ternary.apply();
        }

    }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {  }
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
     apply {
	update_checksum(
	    hdr.ipv4.isValid(),
            { hdr.ipv4.version,
	      hdr.ipv4.ihl,
              hdr.ipv4.diffserv,
              hdr.ipv4.totalLen,
              hdr.ipv4.identification,
              hdr.ipv4.flags,
              hdr.ipv4.fragOffset,
              hdr.ipv4.ttl,
              hdr.ipv4.protocol,
              hdr.ipv4.srcAddr,
              hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum,
            HashAlgorithm.csum16);
    }
}

/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
        packet.emit(hdr.udp);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;

```

### s1-acl.json

```json
{
  "target": "bmv2",
  "p4info": "build/acl.p4.p4info.txt",
  "bmv2_json": "build/acl.json",
  "table_entries": [
    {
      "table": "MyIngress.ipv4_lpm",
      "default_action": true,
      "action_name": "MyIngress.drop",
      "action_params": { }
    },
    {
      "table": "MyIngress.ipv4_lpm",
      "match": {
        "hdr.ipv4.dstAddr": ["10.0.1.1", 32]
      },
      "action_name": "MyIngress.ipv4_forward",
      "action_params": {
        "dstAddr": "00:00:00:00:01:01",
        "port": 1
      }
    },
    {
      "table": "MyIngress.ipv4_lpm",
      "match": {
        "hdr.ipv4.dstAddr": ["10.0.1.2", 32]
      },
      "action_name": "MyIngress.ipv4_forward",
      "action_params": {
        "dstAddr": "00:00:00:00:01:02",
        "port": 2 
      }
    },
    {
      "table": "MyIngress.ipv4_lpm",
      "match": {
        "hdr.ipv4.dstAddr": ["10.0.1.3", 32]
      },
      "action_name": "MyIngress.ipv4_forward",
      "action_params": {
        "dstAddr": "00:00:00:00:01:03",
        "port": 3
      }
    },
    {
      "table": "MyIngress.ipv4_lpm",
      "match": {
        "hdr.ipv4.dstAddr": ["10.0.1.4", 32]
      },
      "action_name": "MyIngress.ipv4_forward",
      "action_params": {
        "dstAddr": "00:00:00:00:01:04",
        "port": 4
      }
    },
    {
      "table": "MyIngress.acl_ternary",
      "match": {
        "hdr.ipv4.dstAddr": ["10.0.1.4", 4294967295]
      },
      "action_name": "MyIngress.drop",
      "action_params": { },
      "priority": 1
    },
    {
      "table": "MyIngress.acl_ternary",
      "match": {
        "hdr.udp.dstPort": [80, 65535]
      },
      "action_name": "MyIngress.drop",
      "action_params": { },
      "priority": 1
    }
  ]
}
```

### topology.json

```json
{
    "hosts": {
        "h1": {"ip": "10.0.1.1/24", "mac": "00:00:00:00:01:01",
               "commands":["arp -i eth0 -s 10.0.1.1 00:00:00:00:01:01",
                           "arp -i eth0 -s 10.0.1.2 00:00:00:00:01:02",
                           "arp -i eth0 -s 10.0.1.3 00:00:00:00:01:03",
                           "arp -i eth0 -s 10.0.1.4 00:00:00:00:01:04"]},
        "h2": {"ip": "10.0.1.2/24", "mac": "00:00:00:00:01:02",
               "commands":["arp -i eth0 -s 10.0.1.1 00:00:00:00:01:01",
                           "arp -i eth0 -s 10.0.1.2 00:00:00:00:01:02",
                           "arp -i eth0 -s 10.0.1.3 00:00:00:00:01:03",
                           "arp -i eth0 -s 10.0.1.4 00:00:00:00:01:04"]},
        "h3": {"ip": "10.0.1.3/24", "mac": "00:00:00:00:01:03",
               "commands":["arp -i eth0 -s 10.0.1.1 00:00:00:00:01:01",
                           "arp -i eth0 -s 10.0.1.2 00:00:00:00:01:02",
                           "arp -i eth0 -s 10.0.1.3 00:00:00:00:01:03",
                           "arp -i eth0 -s 10.0.1.4 00:00:00:00:01:04"]},
        "h4": {"ip": "10.0.1.4/24", "mac": "00:00:00:00:01:04",
               "commands":["arp -i eth0 -s 10.0.1.1 00:00:00:00:01:01",
                           "arp -i eth0 -s 10.0.1.2 00:00:00:00:01:02",
                           "arp -i eth0 -s 10.0.1.3 00:00:00:00:01:03",
                           "arp -i eth0 -s 10.0.1.4 00:00:00:00:01:04"]}
    },
    "switches": {
        "s1": { "runtime_json" : "topo/s1-acl.json" }
    },
    "links": [
        ["h1", "s1-p1"], ["h2", "s1-p2"], ["h3", "s1-p3"], ["h4", "s1-p4"]
    ]
}
```

### 实验结果

运行完成前代码
![incomplete](.\image\acl\incomplete.png)
可见此时报文并未被过滤，`h2`正常接收到了报文

完成代码后检测连通性
![pingall](.\image\acl\pingall.png)
通过添加静态 ARP 的方式实现了 ping 通

测试对端口号为 80 的 UDP 报文的过滤
![UDP 80](.\image\acl\udp 80 can not receive.png)
可见成功过滤了报文

测试对端口号为 90 的 UDP 报文能否正常接收
![UDP 90](.\image\acl\udp 90 received.png)
可见报文并未被过滤

测试对端口号为 80 的 TCP 报文能否正常接收
![TCP 80](.\image\acl\tcp 80 received.png)
可见报文并未被过滤

测试主机`h4`能否接收报文
![TCP 80](.\image\acl\h4 can not receive.png)
因`h4`的 IP 地址`10.0.1.4`已被过滤，所以`h4`无法接收到报文

## 实验总结

+ p4 可以非常方便地实现传统路由无法实现的防火墙功能，而且由于控制层的存在，p4可以随时改写过滤规则，极大的方便了实际的使用。并且在交换机层面上过滤报文，还能避免其它交换机的带宽被垃圾报文占用。
+ 在报头加入特定探针后，p4可以实现在主机上自主选择转发路径来检测路径上各个端口的状况，无论是在进行负载均衡上，还是探测故障交换机上都非常实用。
+ 在 acl 实验中进行了访问控制程序的编写，同时学习了三元组匹配`ternary`的使用，这种方式只关注掩码中为 1 的位来进行匹配。要注意设置`priority`为一个大于 0 的值。

GitHub 仓库链接：[Luoky76](https://github.com/Luoky76/P4-exercise)